#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendPluginRegistry.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Lex/PPCallbacks.h"
#include "clang/Lex/Preprocessor.h"
#include "llvm/Support/CommandLine.h"
#include "clang/CodeGen/ModuleBuilder.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/Basic/SourceLocation.h"
#include "clang/Lex/PPConditionalDirectiveRecord.h"
#include "clang/Lex/PPConditionalDirectiveRecord.h"
#include "clang/Basic/FileManager.h"
#include "clang/Basic/LangOptions.h"
#include "clang/Basic/DiagnosticOptions.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Basic/TargetInfo.h"
#include "clang/Basic/TargetOptions.h"
#include "clang/Lex/HeaderSearch.h"
#include "clang/Lex/HeaderSearchOptions.h"
#include "clang/Lex/ModuleLoader.h"
#include "clang/Lex/PreprocessorOptions.h"
#include <fstream>
#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>
#include <cctype>


using namespace clang;
using namespace llvm;

// synced with ConditionalBlockTypes.cs for easier block identification when parsing the results file generated by the compiler
#define IF_ENUM 0
#define IFDEF_ENUM 1
#define ELIF_ENUM 2
#define ELSE_ENUM 3
#define IFNDEF_ENUM 4
#define ENDIF_ENUM 5

// A custom PPCallback class that will handle macro definitions
class ConditionalBlockInterceptor : public PPCallbacks {
public:
    // Rewrite is used as a hack to encapsulate CompilerInstance since CI does not have an aissgnment operator
    // and Rewriter can set CI
    Rewriter sourceManagerContainerHack;
    std::ofstream resultStream;
    ConditionalBlockInterceptor(CompilerInstance& CI, std::string resultFilePath){
        sourceManagerContainerHack.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());
        this->resultStream.open(resultFilePath);
    }

    void If (SourceLocation Loc, SourceRange ConditionRange, ConditionValueKind ConditionValue){
        
        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);

        PresumedLoc PLocB = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(ConditionRange.getBegin());
        PresumedLoc PLocE = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(ConditionRange.getEnd());

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){
            resultStream << IF_ENUM   << " IF " << PLoc.getLine() << " " << PLoc.getColumn()  << "\n";
            resultStream << "STAR_TLINE " << PLocB.getLine()          << " " << PLocB.getColumn() << "\n"; 
            resultStream << "START_LINE_END "   << PLocE.getLine()          << " " << PLocE.getColumn() << "\n";

            switch (ConditionValue)
            {
            case CVK_NotEvaluated:
                resultStream<<"EVAL NotEvaluated\n";
                break;
            
            case CVK_False:
                resultStream<<"EVAL False\n";
                break;

            case CVK_True:
                resultStream<<"EVAL True\n";
                break;
            default:
                resultStream<<"Undefined\n";   
                break;
            }

            resultStream<<"\n";
        }

        return;
    }

    void Ifdef (SourceLocation Loc, const Token &MacroNameTok, const MacroDefinition &MD){
        
        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);
        PresumedLoc a = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(MacroNameTok.getLocation());

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){

            resultStream << IFDEF_ENUM <<" IFDEF " << PLoc.getLine() << " " << PLoc.getColumn() << "\n";

            resultStream << "START_LINE " << a.getLine() << " " << a.getColumn() << " Length " << MacroNameTok.getLength() << "\n";

            if(MD){
            resultStream << "EVAL TRUE\n";
            }
            else{
                resultStream << "EVAL FALSE\n";
            }
            resultStream<<"\n";
                
            }

        
        return;
    }

    void Elif (SourceLocation Loc, SourceRange ConditionRange, ConditionValueKind ConditionValue, SourceLocation IfLoc){

        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);
        PresumedLoc PIfLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(IfLoc);

        PresumedLoc PLocB = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(ConditionRange.getBegin());
        PresumedLoc PLocE = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(ConditionRange.getEnd());

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){
            resultStream << ELIF_ENUM << " ELIF " << PLoc.getLine() << " " << PLoc.getColumn() << "\n";

            resultStream<<"IFLOC " << PIfLoc.getLine() << " " << PIfLoc.getColumn() << "\n";

            resultStream<<"START_LINE_CONDITION(NOT_USED) " << PLocB.getLine() << " " << PLocB.getColumn() << "\n"; 

            resultStream<<"START_LINE_END " << PLocE.getLine() << " " << PLocE.getColumn() << "\n";

            switch (ConditionValue)
            {
            case CVK_NotEvaluated:
                resultStream << "EVAL NotEvaluated\n";
                break;
            
            case CVK_False:
                resultStream << "EVAL False\n";
                break;

            case CVK_True:
                resultStream << "EVAL True\n";
                break;
            default:
                resultStream << "Undefined\n";
                break;
            }

            resultStream << "\n";
            
        }

        
    }

    void Else (SourceLocation Loc, SourceLocation IfLoc){
        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);
        PresumedLoc PIfLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(IfLoc);

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){
            resultStream << ELSE_ENUM << " ELSE " << PLoc.getLine() << " " << PLoc.getColumn() << "\n";

            resultStream << "IFLOC " << PIfLoc.getLine() << " " << PIfLoc.getColumn() << "\n\n";
        }

    }

    void Ifndef (SourceLocation Loc, const Token &MacroNameTok, const MacroDefinition &MD){
        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);
        PresumedLoc a = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(MacroNameTok.getLocation());

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){
            resultStream << IFNDEF_ENUM <<" IFNDEF " << PLoc.getLine() << " " << PLoc.getColumn() << "\n";

            resultStream << "START_LINE " << a.getLine() << " " << a.getColumn() << " Length " << MacroNameTok.getLength() << "\n";
            
            // observations have showed that we need to inverse the result, idk why :)
            if(!MD){
                resultStream << "EVAL TRUE\n";
            }
            else{
                resultStream << "EVAL FALSE\n";
            }
            resultStream << "\n";
            
        }
    }

    void Endif (SourceLocation Loc, SourceLocation IfLoc){
        PresumedLoc PLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(Loc);
        PresumedLoc PIfLoc = sourceManagerContainerHack.getSourceMgr().getPresumedLoc(IfLoc);

        if(this->sourceManagerContainerHack.getSourceMgr().isWrittenInMainFile(Loc)){
            resultStream << ENDIF_ENUM << " ENDIF " << PLoc.getLine() << " " << PLoc.getColumn() << "\n";

            resultStream << "IFLOC " << PIfLoc.getLine() << " " << PIfLoc.getColumn() << "\n\n";
        }
    }
};


// A custom FrontendAction to add the callback
class MyFrontendAction : public PluginASTAction {
public:
    std::string resultFilePath;
    bool retainExcluded = false;

    MyFrontendAction::ActionType getActionType() override {
        
        return CmdlineAfterMainAction;
    }

    bool ParseArgs (const CompilerInstance &CI, const std::vector<std::string> &args){

        if(args.size() >= 2){
            resultFilePath = std::string(args[0]);

            std::string retainOpt(args[1]);

            if(retainOpt.compare("Discovery") == 0)
                retainExcluded = true;
            else
                retainExcluded = false;
            return true;
        }
        std::cerr<<"Usage: clang++<optional version> -I/usr/include <c file to parse> -Wextra -E -fdirectives-only -P\
        -Xclang -load -Xclang <path to .so library plugin> -Xclang -plugin -Xclang <name of plugin - see FrontendPluginRegistry>\
        -Xclang -plugin-arg-Order <plugin to file that will contain results from running this plugin>\n <Discovery/Trigger> (execution modes for the plugin - see WrapperCompilerPlugin.cs)";
        return false;
    }

    std::unique_ptr<ASTConsumer> CreateASTConsumer (CompilerInstance &CI, StringRef InFile){
        
        // this is used to also detect nested #if, #ifndef, #ifdef, #else, #elif, #endif that may be ingored if the parent is evaluated to false
        // usually the compiler does not retain them
        CI.getPreprocessorOpts().RetainExcludedConditionalBlocks = retainExcluded;
        
        CI.getPreprocessor().addPPCallbacks(std::make_unique<ConditionalBlockInterceptor>(CI, resultFilePath));

        return std::make_unique<ASTConsumer>();
    }

    bool PrepareToExecuteAction (CompilerInstance &CI){

        return true;
    }

    bool BeginInvocation (CompilerInstance &CI){
        return true;
    }
    bool BeginSourceFileAction(CompilerInstance &CI) {
        // resultStream<<CI.getPreprocessor().getPredefines()<<"\n";
        return true;
    }
	
    void EndSourceFileAction() {
        CompilerInstance& CI = getCompilerInstance();
        PPCallbacks* c = CI.getPreprocessor().getPPCallbacks();
        ((ConditionalBlockInterceptor*)c)->~ConditionalBlockInterceptor();
    }
};

// these defines are passed from Makefile which are also passed from PrepSymbolTestEnvFixture
static FrontendPluginRegistry::Add<MyFrontendAction> deployment(REGISTRY_NAME, REGISTRY_DESCRIPTION);
