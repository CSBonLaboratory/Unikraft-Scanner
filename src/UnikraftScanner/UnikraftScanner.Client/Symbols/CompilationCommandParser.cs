namespace UnikraftScanner.Client.Symbols;

using System.Text.RegularExpressions;

public record BaseParsedCommandResult(
    string[] includeTokens,
    string[] orderedSymbolDefineTokens,
    string[] otherTokens,
    string sourceFileAbsPath,
    string compiler,
    string compilerCategory,
    string fullCommand
);

// keep the same order as in the array SupportedCompilers
public enum CompilerCategories
{
    CLANGXX,
    CLANG,
    GXX,
    GCC
}
public class NormalCompilationCommandParser
{
    
    // very important to keep the order like that since there may be variants like clang++-18 which must be in clang++ not clang
    // same goes for g++ before gcc since there may be variants like g++-10
    public static readonly string[] SupportedCompilers = ["clang++", "clang", "g++", "gcc"];
    public virtual BaseParsedCommandResult? ParseCommand(string oDotCmdAbsFilePath)
    {
        // ignore the first 2 characters which are "" from the command (idk why are there but are generated by Unikraft build system)
        string fullCommand = File.ReadAllText(oDotCmdAbsFilePath).Substring(2);

        string[] tokens = Regex.Split(fullCommand, @"\s+");

        // match the first viable compiler category
        string compatCompiler = SupportedCompilers.Aggregate(
            "",
            (acc, c) =>
                tokens[0].Contains(c) ?
                    acc.Equals("") ?
                        c
                        :
                        acc
                    :
                    ""
            );

        if (compatCompiler.Equals(""))
            return null;

        List<string> includes = new(), defines = new(), others = new();

        string sourceFile = null;

        for (int i = 1; i < tokens.Length; i++)
        {
            if (tokens[i].Equals("-D") || tokens[i].Equals("-U"))
            {
                defines.Add(tokens[i]);
                defines.Add(tokens[i + 1]);
                i++;

            }
            else if (tokens[i][0..2].Equals("-D") || tokens[i][0..2].Equals("-U"))
            {
                defines.Add(tokens[i]);
            }
            else if (tokens[i].Equals("-I") || tokens[i].Equals("-include") || tokens[i].Equals("-isystem"))
            {
                includes.Add(tokens[i]);
                includes.Add(tokens[i + 1]);
                i++;
            }
            else if (tokens[i][0..2].Equals("-I"))
            {
                includes.Add(tokens[i]);
            }
            else if (tokens[i].Equals("-c"))
            {
                sourceFile = tokens[i + 1];
                others.Add(tokens[i]);

                if (!tokens[i + 1][^2..].Equals(".c") || !tokens[i + 1][^4..].Equals(".cxx") || !tokens[i + 1][^4..].Equals(".cpp"))
                    return null;
                others.Add(tokens[i + 1]);
                i++;
            }
            else
            {
                others.Add(tokens[i]);
            }
        }

        return new BaseParsedCommandResult(
            includeTokens: includes.ToArray(),
            orderedSymbolDefineTokens: defines.ToArray(),
            otherTokens: others.ToArray(),
            sourceFileAbsPath: sourceFile,
            compiler: tokens[0],
            compilerCategory: compatCompiler,
            fullCommand: fullCommand
        );
    }
}

public class DiscoveryStageCommandParser : NormalCompilationCommandParser
{
    
    // compilation flags used to ignore #include, #define, #line directives that may interfere with the exact locations of the conditional blocks
    private static readonly string additionalFlags = "-Wall -Wextra -E -fdirectives-only -dD -P";
    public override BaseParsedCommandResult? ParseCommand(string oDotCmdAbsFilePath)
    {
        BaseParsedCommandResult res = base.ParseCommand(oDotCmdAbsFilePath);

        if (res == null)
            return null;

        return new BaseParsedCommandResult(
            res.includeTokens,
            res.orderedSymbolDefineTokens,
            res.otherTokens,
            res.sourceFileAbsPath,
            res.compiler,
            res.compilerCategory,
            $"{res.compiler} {String.Join(' ', res.includeTokens)} {String.Join(' ', res.otherTokens)} {additionalFlags}"
        );

    }
}
