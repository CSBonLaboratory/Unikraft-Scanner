namespace UnikraftScanner.Client.Symbols;

using System.Text;
using System.Text.RegularExpressions;
using UnikraftScanner.Client.Helpers;

public record NormalCommandDTO(
    string[] includeTokens,
    string[] orderedSymbolDefineTokens,
    string[] otherTokens,
    string sourceFileAbsPath,
    string compiler,
    string compilerCategory,
    string fullCommand
);

// keep the same order as in the array SupportedCompilers
public enum CompilerCategories
{
    CLANGXX,
    CLANG,
    GXX,
    GCC
}
public class NormalCompilationCommandParser
{
    
    // very important to keep the order like that since there may be variants like clang++-18 which must be in clang++ not clang
    // same goes for g++ before gcc since there may be variants like g++-10
    public static readonly string[] SupportedCompilers = ["clang++", "clang", "g++", "gcc"];
    public virtual ResultUnikraftScanner<NormalCommandDTO> ParseCommand(string oDotCmdAbsFilePath)
    {
        // ignore the first 2 characters which are "" from the command (idk why are there but are generated by Unikraft build system)
        string fullCommand = File.ReadAllText(oDotCmdAbsFilePath).Substring(2);

        string[] tokens = Regex.Split(fullCommand, @"\s+")[0..^1];

        string toolUsed = fullCommand[..fullCommand.IndexOf(' ')];

        // match the first viable compiler category
        string compatCompiler = SupportedCompilers.Aggregate(
            "",
            (acc, c) =>
                toolUsed.Contains(c) ?
                    acc.Equals("") ?
                        c
                        :
                        acc
                    :
                    ""
            );

        if (compatCompiler.Equals(""))
            return ResultUnikraftScanner<NormalCommandDTO>.Failure(
                new ErrorUnikraftScanner<string>(
                    $"Unknown compiler {toolUsed}",
                    ErrorTypes.UnknownCompilerFound
                )
            );

        List<string> includes = new(), defines = new(), others = new();

        string sourceFile = null;

        for (int i = 1; i < tokens.Length; i++)
        {

            if (tokens[i].Equals("-D") || tokens[i].Equals("-U"))
            {
                defines.Add(tokens[i]);
                defines.Add(tokens[i + 1]);
                i++;

            }
            else if (tokens[i][0..2].Equals("-D") || tokens[i][0..2].Equals("-U"))
            {
                defines.Add(tokens[i]);


                if (tokens[i].Contains("=\""))
                {
                    StringBuilder incompleteDefine = new(defines[^1]);
                    for (int incompleteTokenIdx = i + 1; !tokens[incompleteTokenIdx].Contains('"'); incompleteTokenIdx++)
                        incompleteDefine.Append(tokens[incompleteTokenIdx]);
                }
            }
            else if (tokens[i].Equals("-I") || tokens[i].Equals("-include") || tokens[i].Equals("-isystem"))
            {
                includes.Add(tokens[i]);
                includes.Add(tokens[i + 1]);
                i++;
            }
            else if (tokens[i][0..2].Equals("-I"))
            {
                includes.Add(tokens[i]);
            }
            else if (tokens[i].Equals("-c"))
            {
                sourceFile = tokens[i + 1];
                others.Add(tokens[i]);

                if (!tokens[i + 1][^2..].Equals(".c") && !tokens[i + 1][^4..].Equals(".cxx") && !tokens[i + 1][^4..].Equals(".cpp"))
                    return ResultUnikraftScanner<NormalCommandDTO>.Failure(
                        new ErrorUnikraftScanner<string>(
                            $"Source file is not in C language family: {sourceFile}",
                            ErrorTypes.CFamillyCompilerNotFound
                        )
                    );

                others.Add(tokens[i + 1]);
                i++;
            }
            else
            {
                others.Add(tokens[i]);
            }
        }

        return (ResultUnikraftScanner<NormalCommandDTO>)new NormalCommandDTO(
            includeTokens: includes.ToArray(),
            orderedSymbolDefineTokens: defines.ToArray(),
            otherTokens: others.ToArray(),
            sourceFileAbsPath: sourceFile,
            compiler: tokens[0],
            compilerCategory: compatCompiler,
            fullCommand: fullCommand
        );
    }
}
