namespace UnikraftScanner.Client.Symbols;

using System.Text;
using System.Text.RegularExpressions;

public record NormalCommandResult(
    string[] includeTokens,
    string[] orderedSymbolDefineTokens,
    string[] otherTokens,
    string sourceFileAbsPath,
    string compiler,
    string compilerCategory,
    string fullCommand
);

// keep the same order as in the array SupportedCompilers
public enum CompilerCategories
{
    CLANGXX,
    CLANG,
    GXX,
    GCC
}
public class NormalCompilationCommandParser
{
    
    // very important to keep the order like that since there may be variants like clang++-18 which must be in clang++ not clang
    // same goes for g++ before gcc since there may be variants like g++-10
    public static readonly string[] SupportedCompilers = ["clang++", "clang", "g++", "gcc"];
    public virtual NormalCommandResult? ParseCommand(string oDotCmdAbsFilePath)
    {
        // ignore the first 2 characters which are "" from the command (idk why are there but are generated by Unikraft build system)
        string fullCommand = File.ReadAllText(oDotCmdAbsFilePath).Substring(2);

        string[] tokens = Regex.Split(fullCommand, @"\s+")[0..^1];

        string toolUsed = fullCommand[..fullCommand.IndexOf(' ')];

        // match the first viable compiler category
        string compatCompiler = SupportedCompilers.Aggregate(
            "",
            (acc, c) =>
                toolUsed.Contains(c) ?
                    acc.Equals("") ?
                        c
                        :
                        acc
                    :
                    ""
            );

        if (compatCompiler.Equals(""))
            throw new UnknownCompilerFound(toolUsed);

        List<string> includes = new(), defines = new(), others = new();

        string sourceFile = null;

        for (int i = 1; i < tokens.Length; i++)
        {

            if (tokens[i].Equals("-D") || tokens[i].Equals("-U"))
            {
                defines.Add(tokens[i]);
                defines.Add(tokens[i + 1]);
                i++;

            }
            else if (tokens[i][0..2].Equals("-D") || tokens[i][0..2].Equals("-U"))
            {
                defines.Add(tokens[i]);


                if (tokens[i].Contains("=\""))
                {
                    StringBuilder incompleteDefine = new(defines[^1]);
                    for (int incompleteTokenIdx = i + 1; !tokens[incompleteTokenIdx].Contains('"'); incompleteTokenIdx++)
                        incompleteDefine.Append(tokens[incompleteTokenIdx]);
                }
            }
            else if (tokens[i].Equals("-I") || tokens[i].Equals("-include") || tokens[i].Equals("-isystem"))
            {
                includes.Add(tokens[i]);
                includes.Add(tokens[i + 1]);
                i++;
            }
            else if (tokens[i][0..2].Equals("-I"))
            {
                includes.Add(tokens[i]);
            }
            else if (tokens[i].Equals("-c"))
            {
                sourceFile = tokens[i + 1];
                others.Add(tokens[i]);

                if (!tokens[i + 1][^2..].Equals(".c") && !tokens[i + 1][^4..].Equals(".cxx") && !tokens[i + 1][^4..].Equals(".cpp"))
                    throw new CFamilyException($"Source file is not in C lang family: {sourceFile}");

                others.Add(tokens[i + 1]);
                i++;
            }
            else
            {
                others.Add(tokens[i]);
            }
        }

        return new NormalCommandResult(
            includeTokens: includes.ToArray(),
            orderedSymbolDefineTokens: defines.ToArray(),
            otherTokens: others.ToArray(),
            sourceFileAbsPath: sourceFile,
            compiler: tokens[0],
            compilerCategory: compatCompiler,
            fullCommand: fullCommand
        );
    }
}

public class DiscoveryStageCommandParser : NormalCompilationCommandParser
{

    // compilation flags used to ignore #include, #define, #line directives that may interfere with the exact locations of the conditional blocks
    public const string additionalFlags = "-Wall -Wextra -E -fdirectives-only -dD -P";
    public override NormalCommandResult? ParseCommand(string oDotCmdAbsFilePath)
    {
        NormalCommandResult res = base.ParseCommand(oDotCmdAbsFilePath);

        if (res == null)
            return null;
        
        return new NormalCommandResult(
            includeTokens: res.includeTokens,
            orderedSymbolDefineTokens: res.orderedSymbolDefineTokens,
            otherTokens: res.otherTokens,
            sourceFileAbsPath: res.sourceFileAbsPath,
            compiler: res.compiler,
            compilerCategory: res.compilerCategory,
            fullCommand: new StringBuilder()
                .Append(res.compiler)
                .Append(' ')
                .Append(String.Join(' ', res.includeTokens))
                .Append(' ')
                .Append(String.Join(' ', res.otherTokens))
                .Append(' ')
                .Append(additionalFlags).ToString()
        );

    }
}
