#from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service
from seleniumwire import webdriver
from seleniumwire.utils import decode
import os
import time
import json
import logging
USER_EMAIL = os.environ["COVERITY_SCRAPER_USER_EMAIL"]
USER_PASS = os.environ["COVERITY_SCRAPER_PASS"]
PROJECT_NAME = os.environ["COVERITY_PROJECT_NAME"]
FIREFOX_PATH = "/usr/bin/firefox"

# TODO configure paths for GitHub Actions
firefox_path = "/home/karakitay/Desktop/firefox/firefox"
gecko_path = "/snap/bin/geckodriver"

logger = logging.getLogger(__name__)

#TODO: remove logs generated by Selenium


class CoverityAPI(object):

    def __new__(cls) -> None:
        if not hasattr(cls, 'instance'):
            cls.instance = super(CoverityAPI, cls).__new__(cls)
            cls.instance.options = Options()
            cls.instance.options.binary_location = firefox_path
            gecko_service = Service(gecko_path)
            cls.instance.browser = webdriver.Firefox(options=cls.instance.options, service=gecko_service)
        return cls.instance

    def prepare_defects_for_db(self, defect : dict, compilation_tag : str, app_path : str) -> dict:

        # the root path in Coverity defects is mainly the application path (since this is where the cov-build tools starts analysis)
        # and global path if the path is outside the app path:
        # ex: /build/main.c -> defect in ~/.unikraft/apps/random-app/build (we need to bring it to ~/.unikraft/apps/random-app/main.c)
        # ex: ~/.unikraft/unikraft/blabla.c (is outside application path)
        # let's bring all path relative to UK_WORKDIR

        uk_root = os.environ["UK_WORKDIR"]

        # this means that the the file is in the app_path
        if uk_root not in defect['displayFile']:
            logger.info(f"Found defect inside a source file in {app_path}\nOriginal : {defect['displayFile']}\nUnified : {app_path + defect['displayFile']}")
            defect['displayFile'] = app_path + defect['displayFile']


        defect['displayFile'] = os.path.relpath(defect['displayFile'], uk_root)
        defect.update({"compilation_tag" : compilation_tag})

        return defect
    
    def fetch_raw_defects(self) -> list | None:

        print("Starting Firefox")
        self.browser.get('https://scan.coverity.com/users/sign_in')
        user_email_input = self.browser.find_element(By.ID,"user_email")
        user_email_input.send_keys(USER_EMAIL)
        

        user_password_input = self.browser.find_element(By.ID,"user_password")
        user_password_input.send_keys(USER_PASS)

        sign_in_button = self.browser.find_element(By.NAME, "commit")
        sign_in_button.click()

        print("Authentication OK")

        self.browser.find_element(By.LINK_TEXT, PROJECT_NAME).click()
        print("Entering project overview OK")

        self.browser.find_element(By.XPATH,"//a[@href='/projects/unikraft-scanning/view_defects']").click()
        print("Entering defects tab OK")
        
        original_window = self.browser.current_window_handle
        WebDriverWait(self.browser, 40).until(EC.number_of_windows_to_be(2))
        time.sleep(10)
        if self.browser.window_handles[1] != original_window:
            self.browser.switch_to.window(self.browser.window_handles[1])
        else:
            self.browser.switch_to.window(self.browser.window_handles[0])
        print("Switching to second tab in browser where defects are OK")

        time.sleep(20)
        
        self.browser.get("https://scan9.scan.coverity.com/#/project-view/54998/15201") 

        for request in self.browser.requests:
            print(request.url)
            if request.url == "https://scan9.scan.coverity.com/reports/table.json?projectId=15201&viewId=54998":
                if request.response:
                    body_raw = decode(request.response.body, request.response.headers.get('Content-Encoding', 'identity'))
                    body = body_raw.decode()
                    response_json = json.loads(body)
                    return response_json["resultSet"]["results"]
        return None
    
    def check_submition(self, compilation_tag : str) -> bool:
        
        self.browser.get("https://scan9.scan.coverity.com/#/project-view/54994/15201")

        for request in self.browser.requests:
            if request.url == "	https://scan9.scan.coverity.com/reports/table.json?projectId=15201&viewId=54994":
                body_raw = decode(request.response.body, request.response.headers.get('Content-Encoding', 'identity'))
                body = body_raw.decode()
                response_json = json.loads(body)

                if response_json['resultSet']['results'][0]['snapshotDescription'] == compilation_tag:
                    return True
                else:
                    time.sleep(5)
                    return False
        
        time.sleep(5)
        logger.warning("Check the most recent build submition failed. No request with information in response header found. Retrying ...")
        return False
                    
