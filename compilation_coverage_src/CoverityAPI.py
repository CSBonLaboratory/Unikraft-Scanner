#from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service
from seleniumwire import webdriver
from seleniumwire.utils import decode
import os
import time
import json
import logging
import subprocess
USER_EMAIL = os.environ["COVERITY_SCRAPER_USER_EMAIL"]
USER_PASS = os.environ["COVERITY_SCRAPER_PASS"]
PROJECT_NAME = os.environ["COVERITY_PROJECT_NAME"]
FIREFOX_PATH = "/usr/bin/firefox"
COVERITY_SUBMIT_TOKEN = os.environ["COVERITY_SUBMIT_TOKEN"]

# TODO configure paths for GitHub Actions
firefox_path = "/home/karakitay/Desktop/firefox/firefox"
gecko_path = "/snap/bin/geckodriver"

logger = logging.getLogger(__name__)

#TODO: remove logs generated by Selenium


class CoverityAPI(object):

    def __new__(cls) -> None:
        if not hasattr(cls, 'instance'):
            cls.instance = super(CoverityAPI, cls).__new__(cls)
            cls.instance.options = Options()
            cls.instance.options.binary_location = firefox_path
            gecko_service = Service(gecko_path)
            cls.instance.browser = webdriver.Firefox(options=cls.instance.options, service=gecko_service)
        return cls.instance

    def prepare_defects_for_db(self, defect : dict, compilation_tag : str, app_path : str) -> dict:

        
        # just remove the / from the beggining of the path, Coverity adds its since the archive submited is considered to be the whole filesystem

        defect['displayFile'] = defect['displayFile'][1 : ]

        return defect
    
    def fetch_raw_defects(self) -> list | None:

        print("Starting Firefox")
        self.browser.get('https://scan.coverity.com/users/sign_in')
        user_email_input = self.browser.find_element(By.ID,"user_email")
        user_email_input.send_keys(USER_EMAIL)
        

        user_password_input = self.browser.find_element(By.ID,"user_password")
        user_password_input.send_keys(USER_PASS)

        sign_in_button = self.browser.find_element(By.NAME, "commit")
        sign_in_button.click()

        logger.info("Coverity authentication OK")

        self.browser.find_element(By.LINK_TEXT, PROJECT_NAME).click()
        logger.info("Entering project overview OK")

        self.browser.find_element(By.XPATH,"//a[@href='/projects/unikraft-scanning/view_defects']").click()
        logger.info("Entering defects tab OK")
        
        original_window = self.browser.current_window_handle
        WebDriverWait(self.browser, 40).until(EC.number_of_windows_to_be(2))
        time.sleep(10)
        if self.browser.window_handles[1] != original_window:
            self.browser.switch_to.window(self.browser.window_handles[1])
        else:
            self.browser.switch_to.window(self.browser.window_handles[0])
        print("Switching to second tab in browser where defects are OK")

        time.sleep(20)
        
        self.browser.get("https://scan9.scan.coverity.com/#/project-view/54998/15201") 

        for request in self.browser.requests:
            logger.info(request.url)
            if request.url == "https://scan9.scan.coverity.com/reports/table.json?projectId=15201&viewId=54998":
                if request.response:
                    body_raw = decode(request.response.body, request.response.headers.get('Content-Encoding', 'identity'))
                    body = body_raw.decode()
                    response_json = json.loads(body)
                    logger.debug(response_json)
                    return response_json["resultSet"]["results"]
        return None
    
    def check_submition(self, compilation_tag : str) -> bool:
        
        self.browser.get("https://scan9.scan.coverity.com/#/project-view/54994/15201")

        for request in self.browser.requests:
            if request.url == "	https://scan9.scan.coverity.com/reports/table.json?projectId=15201&viewId=54994":
                body_raw = decode(request.response.body, request.response.headers.get('Content-Encoding', 'identity'))
                body = body_raw.decode()
                response_json = json.loads(body)

                if response_json['resultSet']['results'][0]['snapshotDescription'] == compilation_tag:
                    return True
                else:
                    time.sleep(5)
                    return False
        
        time.sleep(5)
        logger.warning("Check the most recent build submition failed. No request with information in response header found. Retrying ...")
        return False
    
    def submit_build(self, app_path : str, pipeline : bool) -> bool:
        
        upload_script_path = os.getcwd() + "/.."

        if pipeline == True:
            job = f"{upload_script_path}/upload.sh --pipeline {app_path}"
        else:
            job = f"{upload_script_path}/upload.sh --manual {app_path}"

        submit_proc = subprocess.Popen(job, shell=True, stdout=subprocess.PIPE)

        out, err = submit_proc.communicate()

        print(out)

        print(err)

        submit_proc.terminate()

        if err != "" or err != None:
            return False

        return True
                    
